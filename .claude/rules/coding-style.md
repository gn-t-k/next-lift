# コーディング規約

コード変更時に適用するルール。

## 開発フロー

1. 実現したい機能や修正内容についてユーザーと合意を取る。（Planモードになっていない場合、Planモードに切り替えるようユーザーに促す）
2. 機能を実現するために必要なモジュールを検討し、ユーザーと合意を取る。
3. スモールステップでモジュールを実装するためのフィードバックループを設計する。（フィードバックループは早ければ早いほどよく、型定義→テストコード→手動の動作確認の順番で優先する）

モジュールの実装前にインターフェースや依存の設計を先に確定するため、モジュールを追加・変更する際は以下のプロセスで進める:

1. まず型定義とテストを書く
2. 型定義とテストの内容をユーザーにレビューさせ、同意を得る
3. 型チェックとテストを通すための最小限の実装を書く
4. 型チェックとテストが通る状態を保ちながらリファクタリング

## コードを説明する情報

- 実装の仕様はテストコードに書く
- 変更の理由はコミットメッセージに書く
- 以下の事情がある場合のみ、コードコメントを書く
  - 実装から自明ではない事情がある場合
  - 長大な関数・複雑な実装（状態管理、暗黙的な依存など）で、コメントがコードリーディングを助ける場合
    - ただし、まずはコードのリファクタを優先する
- コメントと実装の内容が乖離する可能性があるため、コメントは極力書かない
- コメントを書く場合は日本語で記述する

## 関数宣言

- 関数は`function`キーワードではなく、アロー関数（`const functionName = () => {}`）で記述する
- 例外: `function`キーワードでしか書けない処理（例: ジェネレーター関数）の場合のみ許可

## ファイルとエクスポート

- 基本的に1つのファイルからは1つの関数/コンポーネントをexportする
- ファイル名とexportする関数/コンポーネント名を揃える
  - 例: `router-adapter.tsx` → `export const RouterAdapter`
  - 例: `get-user-data.ts` → `export const getUserData`

## 依存パッケージ

- パッケージのバージョンは `^` や `~` などのレンジ指定を使わず、厳密なバージョン番号を指定する
- Renovateを使用して常に最新の状態を保つ
- 新しいパッケージを追加する際は `pnpm add <package>@<version>` を使用
  - package.jsonを直接編集しない
  - 最新バージョンは `npm view <package-name> version` で確認
